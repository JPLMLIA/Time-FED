{
  "cells": [
    {
      "cell_type": "code",
      "source": [
        "%load_ext autoreload\n",
        "%autoreload 2\n",
        "%matplotlib inline\n",
        "\n",
        "import logging\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import warnings\n",
        "\n",
        "from matplotlib.patches import Patch\n",
        "from matplotlib.ticker  import FormatStrFormatter\n",
        "from types import SimpleNamespace as SN\n",
        "\n",
        "from utils import (\n",
        "    load_weather,\n",
        "    load_cn2\n",
        ")\n",
        "\n",
        "# Disable warnings\n",
        "warnings.filterwarnings('ignore')\n",
        "\n",
        "# Disable logger except for errors/exceptions\n",
        "logger = logging.getLogger()\n",
        "logger.setLevel(logging.ERROR)\n"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "collapsed": true,
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "valCount = {\n",
        "    'kind'   : 'bar',\n",
        "    'ylabel' : 'Count',\n",
        "    'logy'   : True,\n",
        "    'figsize': (30, 10)\n",
        "}\n",
        "override = {\n",
        "    'Cn2': {\n",
        "        'logx': True\n",
        "    }\n",
        "}\n",
        "\n",
        "def protect(func):\n",
        "    \"\"\"\n",
        "    Protects a function from raising exceptions to allow for graceful exiting\n",
        "    \"\"\"\n",
        "    def _wrap(*args, **kwargs):\n",
        "        try:\n",
        "            return func(*args, **kwargs)\n",
        "        except Exception as e:\n",
        "            print(f'Function {func.__name__}() raised an exception:\\n{e}')\n",
        "    return _wrap\n",
        "\n",
        "def show(save=False):\n",
        "    \"\"\"\n",
        "    Shows a plot, saves it if set\n",
        "    \"\"\"\n",
        "    plt.tight_layout()\n",
        "    if save:\n",
        "        plt.savefig(save)\n",
        "    plt.show()\n",
        "\n",
        "def generate_histogram(col, df, n_bins=109, save=False):\n",
        "    \"\"\"\n",
        "    Generates a histogram for the provided column and highlights the sigma\n",
        "    regions.\n",
        "    \"\"\"\n",
        "    sigmas = {\n",
        "        1: 'red',\n",
        "        2: 'orange',\n",
        "        3: 'yellow',\n",
        "        4: 'green',\n",
        "        5: 'blue'\n",
        "    }\n",
        "\n",
        "    legend = [Patch(facecolor=colour, label=f'{sigma}Ïƒ', alpha=.3, edgecolor='black') for sigma, colour in sigmas.items()]\n",
        "\n",
        "    ticks = set()\n",
        "\n",
        "    # Gather stats\n",
        "    min  = df[col].min()\n",
        "    max  = df[col].max()\n",
        "    mean = df[col].mean()\n",
        "    std  = df[col].std()\n",
        "\n",
        "    # Create the histogram\n",
        "    ax = df[col].hist(bins=n_bins, log=True, color='grey', figsize=(30, 10))\n",
        "\n",
        "    # Highlight the sigma regions\n",
        "    for sigma, colour in sigmas.items():\n",
        "        lower_x2, upper_x1 = (mean - sigma * std, mean + sigma * std)\n",
        "        lower_x1, upper_x2 = (mean - (sigma + 1) * std, mean + (sigma + 1) * std)\n",
        "        if min < lower_x2:\n",
        "            ax.axvspan(lower_x1, lower_x2, color=colour, alpha=0.3)\n",
        "            ticks.add(lower_x1); ticks.add(lower_x2)\n",
        "        if upper_x1 < max:\n",
        "            ax.axvspan(upper_x1, upper_x2, color=colour, alpha=0.3)\n",
        "            ticks.add(upper_x1); ticks.add(upper_x2)\n",
        "\n",
        "    # Plot the stddev\n",
        "    ax.axvspan(mean, mean, color='red')\n",
        "    ax.axvspan(min, min, color='black')\n",
        "    ax.axvspan(max, max, color='black')\n",
        "\n",
        "    # Change the x-axis ticks to be meaningful\n",
        "    ticks.add(mean)\n",
        "    ax.set_xticks(list(ticks), minor=False)\n",
        "    ax.xaxis.set_minor_formatter(FormatStrFormatter('%.2f'))\n",
        "    ax.tick_params(which='minor', length=0, labeltop=True, labelbottom=False, top=True)\n",
        "    ax.set_xticks([min, max], minor=True)\n",
        "    ax.grid(axis='x', b=False)\n",
        "\n",
        "    # Set some texts\n",
        "    ax.set_title(f'Histogram of {col}, bins={n_bins}')\n",
        "    ax.set_ylabel('Value Count')\n",
        "    ax.set_xlabel('Value')\n",
        "    ax.legend(handles=legend, loc='upper right')\n",
        "\n",
        "    if save:\n",
        "        save = f'{save}/5sigma_hist_{col}.png'\n",
        "    show(save)\n",
        "\n",
        "@protect\n",
        "def analyze(df, drop=True, save=False, name=None):\n",
        "    \"\"\"\n",
        "    Analyzes a provided dataframe with some generic statistics\n",
        "\n",
        "    Assumptions:\n",
        "    - The index is dtype DateTime\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    df : pandas.DataFrame\n",
        "        The DataFrame to perform analysis on\n",
        "    \"\"\"\n",
        "    if save and not name:\n",
        "        print('The `save` parameter was provided but no name was given, please provide a name for this dataset (eg. \"weather\")')\n",
        "        return\n",
        "\n",
        "    # Special printing\n",
        "    fprint = lambda s: print(f\"{'='*80}\\n{s} |\\n{'-'*(len(s)+2)}\")\n",
        "\n",
        "    # Some integrity checks\n",
        "    assert df.index.is_all_dates\n",
        "    df = df.sort_index()\n",
        "\n",
        "    # Drop rows that are entirely empty\n",
        "    if drop:\n",
        "        df = df.dropna(axis=0, how='all')\n",
        "\n",
        "    ## Time analysis\n",
        "    fprint('Time Analysis')\n",
        "\n",
        "    first   = df.index[0]\n",
        "    last    = df.index[-1]\n",
        "    cadence = df.index[1:] - df.index[:-1].values - pd.Timedelta('1 minute')\n",
        "\n",
        "    print(f'There are {df.index.size} rows of timestamps ranging from {first} to {last}.')\n",
        "    print(f'For this range, the average cadence was {cadence.mean()}. Below is a graph showing other differences in cadences discovered.\\n')\n",
        "\n",
        "    ax = cadence.value_counts().sort_index().plot(rot=45, title='Distance between timestamps', xlabel='Distance', **valCount)\n",
        "    show(f'{save}/{name}_time_cadence.png' if save else False)\n",
        "\n",
        "    ## Value analysis\n",
        "    fprint('Value Analysis')\n",
        "\n",
        "    print(f'The total values for each column are as follows:\\n{~df.isna().sum()}')\n",
        "    print(f'\\nThe correlation of these values between columns are provided in the following heatmap:\\n')\n",
        "\n",
        "    fig, ax = plt.subplots(figsize=(5, 5))\n",
        "    ax = sns.heatmap(df.corr(method='pearson'), annot=True, vmin=-1, vmax=1, cmap='RdYlBu', ax=ax)\n",
        "    ax.set_title('Correlation of values between columns{f\" for {name}\" if name else \"\"}')\n",
        "    show(f'{save}/{name}_value_corrs.png' if save else False)\n",
        "\n",
        "    ## NaN analysis\n",
        "    fprint('NaN Analysis')\n",
        "\n",
        "    nandf    = df.isna()\n",
        "    nantotal = nandf.sum()\n",
        "    nancorr  = (nandf * 1).corr(method='pearson')\n",
        "\n",
        "    print(f'The total NaNs for each column are as follows:\\n{nantotal}')\n",
        "    if nancorr.any().any():\n",
        "        print(f'\\nThe correlation of the positions of these nans between columns are provided in the following heatmap:\\n')\n",
        "\n",
        "        fig, ax = plt.subplots(figsize=(5, 5))\n",
        "        ax = sns.heatmap(nancorr, annot=True, vmin=-1, vmax=1, cmap='RdYlBu', ax=ax)\n",
        "        ax.set_title(f'Correlation of NaN positions between columns{f\" for {name}\" if name else \"\"}')\n",
        "        show(f'{save}/{name}_nan_corrs.png' if save else False)\n",
        "\n",
        "    ### Per column analysis\n",
        "    for col in df.columns:\n",
        "        fprint(f'Analysis for Column {col}')\n",
        "        series = df[col]\n",
        "\n",
        "        # Distance between values\n",
        "        valinds = series[~series.isna()].index\n",
        "        cadence = valinds[1:] - valinds[:-1].values - pd.Timedelta('1 minute')\n",
        "        count   = cadence.value_counts()\n",
        "        percent = (valinds.size / series.size) * 100\n",
        "\n",
        "        print(f'The column is {percent:.2f}% dense, {valinds.size} / {series.size}')\n",
        "        print(f'The average distance between values is {cadence.mean()}. Below is a graph showing the various differences in distances between values:\\n')\n",
        "\n",
        "        ax = count.sort_index().iloc[:50].plot(title='Distance between Values', xlabel='Distance', rot=45, **valCount)\n",
        "        show(f'{save}/{name}_dist_between_vals.png' if save else False)\n",
        "\n",
        "        # Average Values\n",
        "        print('\\nThe following graph plots the daily average of each year:')\n",
        "\n",
        "        fig, ax = plt.subplots(figsize=(30, 10))\n",
        "        daily   = series.resample('1D').mean()\n",
        "        years   = pd.date_range(daily.index[0], daily.index[-1], freq='1Y', normalize=True)\n",
        "        for i, year in enumerate(years):\n",
        "            if i == 0:\n",
        "                data = daily[daily.index <= year]\n",
        "            else:\n",
        "                data = daily[(daily.index > years[i-1]) & (daily.index <= year)]\n",
        "\n",
        "            # Reset the index to day of year to remove the year, and plot\n",
        "            data.index = data.index.dayofyear\n",
        "            ax = data.plot(label=year.year, ax=ax, alpha=1)\n",
        "        else:\n",
        "            ax.legend()\n",
        "            ax.set_title(f'Daily Average Value for {col}')\n",
        "            ax.set_xlabel('Day of Year')\n",
        "            ax.set_ylabel('Value')\n",
        "            show(f'{save}/{col}_daily_average.png' if save else False)\n",
        "\n",
        "        # Outliers\n",
        "        print('\\nThe follow graph is a histogram of the given column with the standard deviation regions away from the mean highlighted to show outliers.')\n",
        "        print('The red vertical line is the mean of the column, and each highlighted region is N standard deviations away.')\n",
        "        print('The lower x-axis mark the boundaries of these sigma regions. The upper x-axis mark the min/max values for the series.')\n",
        "        generate_histogram(col, df, save=save)\n"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "collapsed": true,
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "path = 'Weather Data/'\n",
        "\n",
        "#df = load_r0(path, round=True)\n",
        "#df = load_cn2(path, round=True)\n",
        "df = load_weather(path, interpolate=False)\n",
        "\n",
        "df"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "collapsed": true,
        "jupyter": {
          "source_hidden": false,
          "outputs_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    }
  ],
  "metadata": {
    "kernelspec": {
      "argv": [
        "/Users/jamesmo/miniconda3/envs/mloc/bin/python",
        "-m",
        "ipykernel_launcher",
        "-f",
        "{connection_file}"
      ],
      "display_name": "mloc",
      "language": "python",
      "name": "mloc"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}